-- Ensure user_working_sessions is the canonical table with one row per user
-- and proper RLS policies for authenticated access.

-- 1) Ensure canonical table exists.
CREATE TABLE IF NOT EXISTS public.user_working_sessions (
  id bigint generated by default as identity not null,
  user_id uuid not null default auth.uid(),
  latest_workspace_id bigint
);

-- Ensure user_id defaults and nullability are correct.
ALTER TABLE public.user_working_sessions
  ALTER COLUMN user_id SET DEFAULT auth.uid();

-- 2) Ensure primary key exists.
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conname = 'working_sessions_pkey'
      AND conrelid = 'public.user_working_sessions'::regclass
  ) THEN
    ALTER TABLE public.user_working_sessions
      ADD CONSTRAINT working_sessions_pkey PRIMARY KEY (id);
  END IF;
END $$;

-- 3) Backfill from legacy table if it exists.
DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM information_schema.tables
    WHERE table_schema = 'public'
      AND table_name = 'working_sessions'
  ) THEN
    INSERT INTO public.user_working_sessions (user_id, latest_workspace_id)
    SELECT dedup.user_id,
           CASE
             WHEN dedup.workspace_id ~ '^[0-9]+$' THEN dedup.workspace_id::bigint
             ELSE NULL
           END AS latest_workspace_id
    FROM (
      SELECT DISTINCT ON (user_id) user_id, workspace_id, id
      FROM public.working_sessions
      WHERE user_id IS NOT NULL
      ORDER BY user_id, id DESC
    ) AS dedup;
  END IF;
END $$;

-- 4) Normalize existing rows before constraints.
DELETE FROM public.user_working_sessions
WHERE user_id IS NULL;

DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'user_working_sessions'
      AND column_name = 'latest_workspace_id'
      AND data_type = 'text'
  ) THEN
    UPDATE public.user_working_sessions
    SET latest_workspace_id = NULL
    WHERE latest_workspace_id IS NOT NULL
      AND latest_workspace_id !~ '^[0-9]+$';

    ALTER TABLE public.user_working_sessions
      ALTER COLUMN latest_workspace_id TYPE bigint
      USING latest_workspace_id::bigint;
  END IF;
END $$;

DELETE FROM public.user_working_sessions older
USING public.user_working_sessions newer
WHERE older.user_id = newer.user_id
  AND older.id < newer.id;

ALTER TABLE public.user_working_sessions
  ALTER COLUMN user_id SET NOT NULL;

-- 5) Enforce one-to-one on user_id.
CREATE UNIQUE INDEX IF NOT EXISTS user_working_sessions_user_id_key
  ON public.user_working_sessions USING btree (user_id);

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conname = 'user_working_sessions_user_id_key'
      AND conrelid = 'public.user_working_sessions'::regclass
  ) THEN
    ALTER TABLE public.user_working_sessions
      ADD CONSTRAINT user_working_sessions_user_id_key
      UNIQUE USING INDEX user_working_sessions_user_id_key;
  END IF;
END $$;

UPDATE public.user_working_sessions
SET latest_workspace_id = NULL
WHERE latest_workspace_id IS NOT NULL
  AND NOT EXISTS (
    SELECT 1
    FROM public.workspaces w
    WHERE w.id = user_working_sessions.latest_workspace_id
  );

-- 6) Ensure foreign keys exist.
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conname = 'user_working_sessions_user_id_fkey'
      AND conrelid = 'public.user_working_sessions'::regclass
  ) THEN
    ALTER TABLE public.user_working_sessions
      ADD CONSTRAINT user_working_sessions_user_id_fkey
      FOREIGN KEY (user_id) REFERENCES public.user_profiles (id)
      ON UPDATE CASCADE
      ON DELETE CASCADE;
  END IF;
END $$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conname = 'user_working_sessions_latest_workspace_id_fkey'
      AND conrelid = 'public.user_working_sessions'::regclass
  ) THEN
    ALTER TABLE public.user_working_sessions
      ADD CONSTRAINT user_working_sessions_latest_workspace_id_fkey
      FOREIGN KEY (latest_workspace_id) REFERENCES public.workspaces (id)
      ON UPDATE CASCADE
      ON DELETE SET NULL;
  END IF;
END $$;

-- 7) Drop legacy table if present.
DROP TABLE IF EXISTS public.working_sessions;

-- 8) Apply grants and RLS policies.
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.user_working_sessions TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.user_working_sessions TO service_role;

ALTER TABLE public.user_working_sessions ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can read own working session" ON public.user_working_sessions;
DROP POLICY IF EXISTS "Users can insert own working session" ON public.user_working_sessions;
DROP POLICY IF EXISTS "Users can update own working session" ON public.user_working_sessions;
DROP POLICY IF EXISTS "Users can delete own working session" ON public.user_working_sessions;

CREATE POLICY "Users can read own working session"
ON public.user_working_sessions
FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own working session"
ON public.user_working_sessions
FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own working session"
ON public.user_working_sessions
FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own working session"
ON public.user_working_sessions
FOR DELETE
USING (auth.uid() = user_id);
